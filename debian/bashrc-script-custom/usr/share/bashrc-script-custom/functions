# Custom functions like git-push, vencord-discord, find-unsure, git-clone
vencord-discord() {
    # check argument
    if [ $# -ne 1 ]; then
        echo -e "\e[33mUsage:\e[0m \e[34mvencord-discord install\e[0m/\e[34mupdate\e[0m"
        return 1
    fi

    local type_install="$1"

    echo "=== $type_install Discord client ==="

    echo "=== Downloading the latest stable version of Discord ==="
    curl -o discord.tar.gz -J --location-trusted --max-redirs 10 "https://discord.com/api/download/stable?platform=linux&format=tar.gz"

    echo "=== Extracting Discord archive ==="
    tar -xzf discord.tar.gz

    echo "=== Installing/Updating Discord files to /opt/discord/ ==="
    sudo mkdir -p /opt/discord
    sudo cp -r Discord/* /opt/discord/

    echo "=== Modifying the desktop file for custom folder ==="
    sudo sed -i 's|Exec=/usr/share/discord/Discord|Exec=/usr/bin/discord|' /opt/discord/discord.desktop
    sudo sed -i 's|Icon=discord|Icon=/opt/discord/discord.png|' /opt/discord/discord.desktop

    echo "=== Installing Discord ==="
    if [ "$1" == "install" ]; then
        # set symlink
        sudo ln -sf /opt/discord/Discord /usr/bin/discord

        echo ""
    fi

    echo "=== Set ownership and add execute permission ==="
    sudo chown root:root -R /opt/discord/
    sudo chmod -R +x /opt/discord/

    echo "=== Delete temp files ==="
    rm -rf discord.tar.gz Discord

    echo "Launching Vencord Installer/Updater..."
    sh -c "$(curl -sS https://raw.githubusercontent.com/Vendicated/VencordInstaller/main/install.sh)"

    echo -e "\e[32m✓ Operation completed successfully!\e[0m"
}

# Fonction git-push
git-push() {
    # Validate first argument (commit message)
    if [ $# -lt 1 ]; then
        echo -e "\e[33mUsage: git-push \"commit message\" [branch]\e[0m"
        return 1
    fi

    local commit_message="$1"
    local branch="$2"

    # If branch not provided, use current branch
    if [ -z "$branch" ]; then
        branch=$(git branch --show-current)
        if [ -z "$branch" ]; then
            echo -e "\e[31m✗ Error: Unable to determine current branch. Please specify a branch.\e[0m"
            return 1
        fi
        echo -e "\e[33m Using current branch: $branch\e[0m"
    fi

    # If there is no commit yet
    if ! git rev-parse HEAD >/dev/null 2>&1; then
        echo -e "\e[31m✗ No commits yet. Creating initial commit...\e[0m"
        git add .
        if ! git commit -m "$commit_message"; then
            echo -e "\e[31m✗ Error while creating the initial commit.\e[0m"
            return 1
        fi
        echo "Pushing to branch: $branch"
        if ! git push origin "$branch"; then
            echo -e "\e[31m✗ Error during push.\e[0m"
            return 1
        fi
        echo -e "\e[32m✓ Initial commit and push succeeded!\e[0m"
        return 0
    fi

    echo -e "\e[32m=== Synchronizing with remote ===\e[0m"

    # Fetch latest changes
    echo "Fetching latest changes from remote..."
    if ! git fetch origin; then
        echo -e "\e[31m✗ Error during fetch. Aborting.\e[0m"
        return 1
    fi

    # Ensure we're on the correct branch
    current_branch=$(git branch --show-current)
    if [ "$current_branch" != "$branch" ]; then
        echo "Switching to branch: $branch"
        if ! git checkout "$branch"; then
            echo -e "\e[31m✗ Error switching branch. Aborting.\e[0m"
            return 1
        fi
    fi

    # Check for remote changes
    local_commit=$(git rev-parse HEAD)
    remote_commit=$(git rev-parse "origin/$branch" 2>/dev/null)

    if [ "$local_commit" != "$remote_commit" ]; then
        echo "Remote changes detected. Updating local..."
        if ! git pull origin "$branch"; then
            echo -e "\e[31m✗ Error during pull. Please resolve conflicts manually.\e[0m"
            return 1
        fi
        echo "✓ Synchronization completed successfully."
    else
        echo "✓ Local repository is already up to date."
    fi

    echo -e "\e[32m=== Creating and pushing commit ===\e[0m"

    # If there are no changes to commit
    if git diff --quiet && git diff --cached --quiet; then
        echo -e "\e[35mNo changes to commit.\e[0m"
        return 0
    fi

    # Stage changes
    echo "Staging modified files..."
    git add .

    # Commit
    echo "Creating commit with message: '$commit_message'"
    if ! git commit -m "$commit_message"; then
        echo -e "\e[31m✗ Error while creating the commit.\e[0m"
        return 1
    fi

    # Push
    echo "Pushing to branch: $branch"
    if ! git push origin "$branch"; then
        echo -e "\e[31m✗ Error during push.\e[0m"
        return 1
    fi

    echo -e "\e[32m✓ Operation completed successfully!\e[0m"
}

# Fonction find files if unsure about name
find-unsure() {
    if [ $# -ne 1 ]; then
        echo -e "\e[33mUsage:\e[0m \e[34mfind-unsure\e[0m \e[33m<name file>\e[0m"
        return 1
    fi

    local file_name="$1"

    command find ~ -iname "*$file_name*"
}

git-clone() {
    # Validate arguments
    if [ $# -ne 1 ]; then
        echo -e "\e[33mUsage: git-clone <repo url>\e[0m"
        return 1
    fi

    local repo_url="$1"

    # Input select for user name and email from the file .git_identities
    if [ ! -f "$HOME/.git_identities" ]; then
        echo -e "\e[31m✗ The file ~/.git_identities does not exist. Please create git profiles first.\e[0m"
        return 1
    fi

    echo "Select a git profile:"
    mapfile -t profiles < <(
        grep -E '^\[user\]$' -A 2 "$HOME/.git_identities" \
        | grep -E 'name = |email = ' \
        | sed 's/^[[:space:]]*//' \
        | paste - - \
        | sed 's/ name = /, /' \
        | sed 's/ email = /, /'
    )
    select profile in "${profiles[@]}"; do
        if [ -n "$profile" ]; then
            git_name=$(echo "$profile" | cut -d',' -f1 | sed 's/name = //')
            git_email=$(echo "$profile" | cut -d',' -f2 | sed 's/email = //')
            break
        else
            echo -e "\e[31m✗ Invalid selection. Please try again.\e[0m"
        fi
    done

    # Clone the repo
    echo "Cloning repo: $repo_url"
    if ! git clone "$repo_url"; then
        echo -e "\e[31m✗ Error cloning the repo.\e[0m"
        return 1
    fi

    # cd into the cloned repo directory
    repo_dir=$(basename "$repo_url" .git)
    cd "$repo_dir" || { echo -e "\e[31m✗ Error: Unable to enter the cloned repo directory.\e[0m"; return 1; }

    echo "Using profile: $git_name <$git_email>"
    git config user.name "$git_name"
    git config user.email "$git_email"

    echo -e "\e[32m✓ Repo cloned successfully!\e[0m"
}

git-create-repo() {
    # Validate arguments
    if [ $# -ne 2 ]; then
        echo -e "\e[33mUsage: git-create-repo <repo name> <public|private>\e[0m"
        return 1
    fi

    local repo_name="$1"
    local visibility="$2"

    if [[ "$visibility" != "public" && "$visibility" != "private" ]]; then
        echo -e "\e[31m✗ Error: Visibility must be 'public' or 'private'.\e[0m"
        return 1
    fi

    # Load git profiles
    if [ ! -f "$HOME/.git_identities" ]; then
        echo -e "\e[31m✗ The file ~/.git_identities does not exist.\e[0m"
        return 1
    fi

    echo "Select a git profile:"
    local -a profiles names emails
    local in_user_section=0
    local current_name="" current_email=""

    while IFS= read -r line; do
        if [[ "$line" =~ ^\[user\]$ ]]; then
            in_user_section=1
            current_name=""
            current_email=""
        elif [[ $in_user_section -eq 1 ]]; then
            if [[ "$line" =~ ^[[:space:]]*name[[:space:]]*=[[:space:]]*(.+)$ ]]; then
                current_name="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^[[:space:]]*email[[:space:]]*=[[:space:]]*(.+)$ ]]; then
                current_email="${BASH_REMATCH[1]}"
                if [ -n "$current_name" ]; then
                    profiles+=("$current_name <$current_email>")
                    names+=("$current_name")
                    emails+=("$current_email")
                    in_user_section=0
                fi
            elif [[ "$line" =~ ^\[.*\]$ ]]; then
                in_user_section=0
            fi
        fi
    done < "$HOME/.git_identities"

    if [ ${#profiles[@]} -eq 0 ]; then
        echo -e "\e[31m✗ No profile found in ~/.git_identities\e[0m"
        return 1
    fi

    select profile in "${profiles[@]}"; do
        if [ -n "$profile" ]; then
            local idx=$((REPLY - 1))
            git_name="${names[$idx]}"
            git_email="${emails[$idx]}"
            break
        else
            echo -e "\e[31m✗ Invalid selection. Please try again.\e[0m"
        fi
    done

    echo -e "Selected profile: $git_name <$git_email>\n"

    # Ask if repo already exists locally
    echo "Does the repo already exist locally? (y/n)"
    read -r response

    if [[ "$response" =~ ^[Yy]$ ]]; then
        # CASE 1: Existing repo - find and link
        echo -e "\nSearching for repo '$repo_name' on the system..."
        mapfile -t local_repos < <(find ~ -type d -iname "$repo_name" -exec test -d "{}/.git" \; -print 2>/dev/null)
        
        local target_dir=""
        if [ ${#local_repos[@]} -gt 1 ]; then
            echo "Multiple local directories found:"
            select sel in "${local_repos[@]}"; do
                if [ -n "$sel" ]; then
                    target_dir="$sel"
                    break
                else
                    echo -e "\e[31m✗ Invalid selection.\e[0m"
                fi
            done
        elif [ ${#local_repos[@]} -eq 1 ]; then
            target_dir="${local_repos[0]}"
            echo "Directory found: $target_dir"
        else
            echo -e "\e[31m✗ Error: No git repo named '$repo_name' found.\e[0m"
            return 1
        fi

        cd "$target_dir" || { echo -e "\e[31m✗ Error: Unable to access the directory.\e[0m"; return 1; }

        # Configure profile
        git config user.name "$git_name"
        git config user.email "$git_email"

        # Check for existing remote
        if git remote get-url origin &>/dev/null; then
            echo -e "\e[33m⚠ Warning: An 'origin' remote already exists:\e[0m"
            git remote get-url origin
            echo "Do you want to replace it? (y/n)"
            read -r replace
            if [[ ! "$replace" =~ ^[Yy]$ ]]; then
                echo -e "\e[32mOperation cancelled.\e[0m"
                return 0
            fi
            git remote remove origin
        fi

        # Check for commits
        if ! git rev-parse HEAD &>/dev/null; then
            echo -e "\e[33mThe repo has no commits. Creating an initial commit...\e[0m"
            if [ ! -f "README.md" ]; then
                echo "# $repo_name" > README.md
                git add README.md
            else
                # If README exists, add all files
                git add -A
            fi
            git commit -m "Initial commit" || {
                echo -e "\e[31m✗ Error creating the initial commit.\e[0m"
                return 1
            }
        fi

        echo -e "\n\e[32mCreating remote repo and pushing...\e[0m"
        if ! gh repo create "$repo_name" --"$visibility" --source=. --remote=origin --push; then
            echo -e "\e[31m✗ Error creating the remote repo.\e[0m"
            return 1
        fi

        echo -e "\e[32m✓ Remote repo created and linked successfully!\e[0m"
        echo -e "Repository: $(git remote get-url origin)"
        return 0
    fi

    # CASE 2: New repo - full creation
    if [ -d "$repo_name" ]; then
        echo -e "\e[31m✗ Error: The directory '$repo_name' already exists in $(pwd)\e[0m"
        return 1
    fi

    echo -e "\nCreating local directory: $repo_name"
    mkdir -p "$repo_name"
    cd "$repo_name" || { echo -e "\e[31m✗ Error: Unable to access the directory.\e[0m"; return 1; }

    # Git init
    git init
    git branch -M main
    git config user.name "$git_name"
    git config user.email "$git_email"

    # Initial commit
    echo "# $repo_name" > README.md
    git add README.md
    git commit -m "Initial commit"

    # Create remote repo
    echo -e "\nCreating remote repo on GitHub..."
    if ! gh repo create "$repo_name" --"$visibility" --source=. --remote=origin --push; then
        echo -e "\e[31m✗ Error creating the remote repo.\e[0m"
        return 1
    fi

    echo -e "\e[32m✓ Local and remote repos created successfully!\e[0m"
    echo -e "Repository: $(git remote get-url origin)"
    echo -e "Local path: $(pwd)"
}

# Delete a remote and/or local repo (Github CLI)
git-delete-repo() {
    # Validate arguments
    if [ $# -ne 2 ]; then
        echo -e "\e[33mUsage: git-delete-repo <repo name> <local|remote|both>\e[0m"
        return 1
    fi

    local repo_name="$1"
    local delete_type="$2"

    if [[ "$delete_type" != "local" && "$delete_type" != "remote" && "$delete_type" != "both" ]]; then
        echo -e "\e[31m✗ Error: delete type must be 'local', 'remote' or 'both'.\e[0m"
        return 1
    fi

    echo -e "\e[33m⚠ Warning: This operation is irreversible!\e[0m"
    echo -e "\e[33mYou are about to delete the repo '$repo_name' with mode '$delete_type'.\e[0m"
    echo -e "\e[33mDo you confirm this action? (y/n)\e[0m"
    read -r confirmation

    if [[ ! "$confirmation" =~ ^[Yy]$ ]]; then
        echo -e "\e[32mOperation cancelled by user.\e[0m"
        return 0
    fi

    # Determine full remote name
    local remote_full="$repo_name"
    if [[ "$repo_name" != */* ]]; then
        local gh_user
        gh_user=$(gh api user --jq .login 2>/dev/null) || gh_user=""
        if [ -n "$gh_user" ]; then
            remote_full="$gh_user/$repo_name"
        fi
    fi

    # Delete remote repo
    if [[ "$delete_type" == "remote" || "$delete_type" == "both" ]]; then
        echo -e "\nDeleting remote repo: $remote_full"
        if ! gh repo delete "$remote_full" --yes; then
            echo -e "\e[31m✗ Error deleting the remote repo.\e[0m"
            echo -e "\e[33mIf the error is permission-related, refresh scopes:\e[0m"
            echo -e "\e[34m> gh auth refresh -h github.com -s delete_repo\e[0m"
            echo -e "\e[34m  or verify whether the remote repo exists and you have rights to delete it.\e[0m"
            # Do not exit here if local deletion is still requested
            if [[ "$delete_type" == "remote" ]]; then
                return 1
            fi
        else
            echo -e "\e[32m✓ Remote repo deleted successfully!\e[0m"
        fi
    fi

    # Delete local repo if requested
    if [[ "$delete_type" == "local" || "$delete_type" == "both" ]]; then
        echo -e "\nSearching for local repos named '$repo_name'..."
        mapfile -t matches < <(find ~ -type d -iname "$repo_name" -exec test -d "{}/.git" \; -print 2>/dev/null)

        local selected_dir=""
        if [ ${#matches[@]} -gt 1 ]; then
            echo "Multiple local repos found:"
            select sel in "${matches[@]}"; do
                if [ -n "$sel" ]; then
                    selected_dir="$sel"
                    break
                else
                    echo -e "\e[31m✗ Invalid selection.\e[0m"
                fi
            done
        elif [ ${#matches[@]} -eq 1 ]; then
            selected_dir="${matches[0]}"
            echo "Repo found: $selected_dir"
        else
            echo -e "\e[33mNo local repo found via search.\e[0m"
            # Fallback: check current working directory
            if [ -d "$repo_name/.git" ]; then
                selected_dir="$repo_name"
                echo "✓ Repo found in current directory: $selected_dir"
            fi
        fi

        if [ -n "$selected_dir" ]; then
            echo "Deleting local directory: $selected_dir"
            rm -rf -- "$selected_dir"
            echo -e "\e[32m✓ Local directory deleted successfully!\e[0m"
        else
            echo -e "\e[31m✗ Error: No local repo '$repo_name' found.\e[0m"
            return 1
        fi
    fi

    echo -e "\n\e[32m✓ Operation completed successfully!\e[0m"
}