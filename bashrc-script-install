#!/usr/bin/env bash

# Bashrc Configuration Script
# Vue CLI-style interactive tool to add aliases, functions, and configurations to .bashrc

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
GRAY='\033[1;30m'
NC='\033[0m' # No Color

# Variable pour stocker le fichier de configuration sélectionné
USER_FILE_SELECTED=""

# Dossier contenant les scripts de configuration
# Priorité: local d'abord (dev), puis système (production)
if [ -d "./scripts" ]; then
    CONFIG_DIR="./scripts"
    echo -e "${YELLOW}Mode développement: utilisation du dossier local ./scripts${NC}"
elif [ -d "/usr/share/bashrc-script-custom" ]; then
    CONFIG_DIR="/usr/share/bashrc-script-custom"
else
    echo -e "${RED}Error: Configuration directory not found!${NC}"
    echo -e "${RED}Searched in: ./scripts and /usr/share/bashrc-script-custom${NC}"
    exit 1
fi

echo -e "${GRAY}Using config directory: $CONFIG_DIR${NC}"

# Générer dynamiquement les clés et descriptions
CONFIG_KEYS=()
declare -A CONFIG_OPTIONS=()

if [ ! -d "$CONFIG_DIR" ] || [ -z "$(ls -A "$CONFIG_DIR")" ]; then
    echo -e "${RED}Erreur : Aucun script trouvé dans le dossier ${CONFIG_DIR}.${NC}"
    
    exit 1
fi

for file in "$CONFIG_DIR"/*; do
    [ -e "$file" ] || continue
    key=$(basename "$file")
    CONFIG_KEYS+=("$key")
    # Lire la première ligne pour la description
    desc=$(head -n 1 "$file" | sed 's/^# *//')
    CONFIG_OPTIONS["$key"]="$desc"
done

declare -A SELECTED_OPTIONS=()
CURRENT_SELECTION=0

# Function to select configuration file
select_config_file() {
    echo
    echo -e "${CYAN}Configuration File Selection${NC}"
    echo -e "${GRAY}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo
    echo -e "${GREEN}Dans quel fichier souhaitez-vous ajouter les configurations ?${NC}"
    echo
    echo -e "  ${CYAN}1)${NC} ~/.bashrc   ${GRAY}(Bash - chargé pour les shells interactifs)${NC}"
    echo -e "  ${CYAN}2)${NC} ~/.profile  ${GRAY}(Compatible Bash/Sh - chargé au login)${NC}"
    echo -e "  ${CYAN}3)${NC} ~/.zshrc    ${GRAY}(Zsh - pour les utilisateurs de Zsh)${NC}"
    echo
    
    while true; do
        read -rp "Votre choix [1-3] : " choice
        case $choice in
            1)
                USER_FILE_SELECTED="$HOME/.bashrc"
                break
                ;;
            2)
                USER_FILE_SELECTED="$HOME/.profile"
                break
                ;;
            3)
                USER_FILE_SELECTED="$HOME/.zshrc"
                break
                ;;
            *)
                echo -e "${RED}Choix invalide. Veuillez entrer 1, 2 ou 3.${NC}"
                ;;
        esac
    done
    
    echo -e "${GREEN}✓${NC} Fichier sélectionné : ${CYAN}$USER_FILE_SELECTED${NC}"
}

# Function to draw the selection interface
draw_interface() {
    clear
    echo -e "${CYAN}"
    echo "Bashrc CLI v1.0.0"
    echo
    echo -e "${NC}? ${GREEN}Please pick a preset:${NC} ${GRAY}Manually select features${NC}"
    echo -e "${NC}? ${GREEN}Check the features needed for your project:${NC}"
    echo

    local i=0
    for key in "${CONFIG_KEYS[@]}"; do
        local prefix="  "
        local color="${NC}"
        local checkbox="◯"

        # Highlight current selection
        if [ $i -eq $CURRENT_SELECTION ]; then
            prefix="> "
            color="${CYAN}"
        fi

        # Show selected items
        if [[ ${SELECTED_OPTIONS[$key]} == "1" ]]; then
            checkbox="◉"
        fi

        echo -e "${color}${prefix}${checkbox} ${CONFIG_OPTIONS[$key]}${NC}"
        ((i++))
    done

    echo
    echo -e "${GRAY}(Use arrow keys to move, <s> to select, <a> to toggle all, <i> to invert selection, <e> to confirm)${NC}"
}

# Function to handle user input
handle_input() {
    local key

    # Read a single character
    read -rsn1 key

    # Handle escape sequences (arrow keys)
    if [[ $key == $'\e' ]]; then
        read -rsn2 -t 0.1 key
        case $key in
            "[A") # Up arrow
                ((CURRENT_SELECTION--))
                if [ $CURRENT_SELECTION -lt 0 ]; then
                    CURRENT_SELECTION=$((${#CONFIG_KEYS[@]} - 1))
                fi
                ;;
            "[B") # Down arrow
                ((CURRENT_SELECTION++))
                if [ $CURRENT_SELECTION -ge ${#CONFIG_KEYS[@]} ]; then
                    CURRENT_SELECTION=0
                fi
                ;;
        esac
    else
        case $key in
            's'|'S') # S key - toggle selection
                local current_key=${CONFIG_KEYS[$CURRENT_SELECTION]}
                if [[ ${SELECTED_OPTIONS[$current_key]} == "1" ]]; then
                    SELECTED_OPTIONS[$current_key]=""
                else
                    SELECTED_OPTIONS[$current_key]="1"
                fi
                ;;
            'a'|'A') # Toggle all
                local all_selected=1
                for key in "${CONFIG_KEYS[@]}"; do
                    if [[ ${SELECTED_OPTIONS[$key]} != "1" ]]; then
                        all_selected=0
                        break
                    fi
                done

                if [ $all_selected -eq 1 ]; then
                    # Deselect all
                    for key in "${CONFIG_KEYS[@]}"; do
                        SELECTED_OPTIONS[$key]=""
                    done
                else
                    # Select all
                    for key in "${CONFIG_KEYS[@]}"; do
                        SELECTED_OPTIONS[$key]="1"
                    done
                fi
                ;;
            'i'|'I') # Invert selection
                for key in "${CONFIG_KEYS[@]}"; do
                    if [[ ${SELECTED_OPTIONS[$key]} == "1" ]]; then
                        SELECTED_OPTIONS[$key]=""
                    else
                        SELECTED_OPTIONS[$key]="1"
                    fi
                done
                ;;
            'e'|'E') # E key - confirm selection
                return 1 # Signal to exit
                ;;
            'q'|'Q'|$'\x03') # q or Ctrl+C
                echo
                echo -e "${YELLOW}Configuration cancelled.${NC}"
                exit 0
                ;;
        esac
    fi
    return 0
}

# Function to show the selection interface
show_selection_interface() {
    # Configure terminal for raw input
    stty -echo -icanon min 1 time 0

    while true; do
        draw_interface
        if ! handle_input; then
            break
        fi
    done

    # Restore terminal settings
    stty echo icanon

    # Check if any options were selected
    local has_selections=0
    for key in "${CONFIG_KEYS[@]}"; do
        if [[ ${SELECTED_OPTIONS[$key]} == "1" ]]; then
            has_selections=1
            break
        fi
    done

    if [ $has_selections -eq 0 ]; then
        echo
        echo -e "${YELLOW}No configurations selected. Exiting.${NC}"
        exit 0
    fi
}

# Function to backup configuration file
backup_config_file() {
    if [ -f "$USER_FILE_SELECTED" ]; then
        local filename=$(basename "$USER_FILE_SELECTED")
        local backup_name="$USER_FILE_SELECTED.backup.$(date +%Y%m%d_%H%M%S)"
        cp "$USER_FILE_SELECTED" "$backup_name"
        echo -e "${GREEN}✓${NC} Backup created: $backup_name"
    else
        echo -e "${YELLOW}⚠${NC} File $USER_FILE_SELECTED doesn't exist yet, creating it..."
        touch "$USER_FILE_SELECTED"
    fi
}

# Main function
main() {
    # clear the screen
    clear
    echo -e "${CYAN}Bashrc CLI v1.0.1${NC}"
    # === Sélection du fichier de configuration ===
    select_config_file
    
    echo
    # === Ajout du prompt pour les profils git ===
    read -rp "Voulez-vous ajouter un ou plusieurs profils git (user.name/user.email) ? (o/n) : " add_git_profiles
    if [[ "$add_git_profiles" =~ ^[oOyY]$ ]]; then
        GIT_IDENTITIES_FILE="$HOME/.git_identities"
        > "$GIT_IDENTITIES_FILE"
        while true; do
            read -rp "Nom du profil (user.name) : " git_name
            read -rp "Email du profil (user.email) : " git_email
            echo "[user]" >> "$GIT_IDENTITIES_FILE"
            echo "    name = $git_name" >> "$GIT_IDENTITIES_FILE"
            echo "    email = $git_email" >> "$GIT_IDENTITIES_FILE"
            read -rp "Ajouter un autre profil ? (o/n) : " another
            [[ "$another" =~ ^[oOyY]$ ]] || break
        done
        echo -e "${GREEN}Profils git enregistrés dans $GIT_IDENTITIES_FILE et alias ajoutés à $USER_FILE_SELECTED${NC}"
    fi

    echo
    echo -e "${GREEN}🎉 Successfully created git user(s) !${NC}"
 
    # Show the Vue CLI-style interface
    show_selection_interface

    clear
    echo -e "${CYAN}Bashrc CLI v1.0.0${NC}"
    echo
    echo -e "${GREEN}✨ Creating configuration...${NC}"
    echo

    # Show selected configurations
    echo -e "${GREEN}Selected configurations:${NC}"
    for key in "${CONFIG_KEYS[@]}"; do
        if [[ ${SELECTED_OPTIONS[$key]} == "1" ]]; then
            echo -e "  ${GREEN}◉${NC} ${CONFIG_OPTIONS[$key]}"
        fi
    done
    echo

    # Create backup
    backup_config_file

    # Add configurations
    echo -e "${BLUE}🔧 Adding configurations to $USER_FILE_SELECTED...${NC}"

    # Add header comment
    echo "" >> "$USER_FILE_SELECTED"
    echo "# === Added by Bashrc Configurator $(date) ===" >> "$USER_FILE_SELECTED"

    for key in "${CONFIG_KEYS[@]}"; do
        if [[ ${SELECTED_OPTIONS[$key]} == "1" ]]; then
            file="$CONFIG_DIR/$key"
            desc="# ${CONFIG_OPTIONS[$key]}"
            # Vérification si le bloc existe déjà (on cherche la description)
            if ! grep -qF "$desc" "$USER_FILE_SELECTED"; then
                echo -e "  ${GREEN}✓${NC} Adding ${CONFIG_OPTIONS[$key]}"
                cat "$file" >> "$USER_FILE_SELECTED"
                echo "
                " >> "$USER_FILE_SELECTED"
            else
                echo -e "  ${YELLOW}⚠ ${NC} ${CONFIG_OPTIONS[$key]} already present, skipping."
            fi
        fi
    done

    echo "# === End of Bashrc Configurator additions ===" >> "$USER_FILE_SELECTED"
    echo "" >> "$USER_FILE_SELECTED"

    echo
    echo -e "${GREEN}🎉 Successfully created configuration!${NC}"
    echo
    echo -e "${YELLOW}Get started with the following commands:${NC}"
    echo
    
    # Afficher la commande appropriée selon le fichier sélectionné
    local filename=$(basename "$USER_FILE_SELECTED")
    echo -e " ${GRAY}\$${NC} ${CYAN}source $USER_FILE_SELECTED${NC}"
    
    if [[ "$filename" == ".zshrc" ]]; then
        echo -e " ${GRAY}\$${NC} ${CYAN}# Or restart your terminal / open a new zsh session${NC}"
    else
        echo -e " ${GRAY}\$${NC} ${CYAN}# Or restart your terminal${NC}"
    fi
    
    echo
    echo -e "${GRAY}You can always restore from backup if needed.${NC}"
}

# Trap to restore terminal settings on exit
trap 'stty echo icanon' EXIT

# Check if we're in a terminal that supports the required features
if [ ! -t 0 ]; then
    echo -e "${RED}Error: This script requires an interactive terminal.${NC}"
    exit 1
fi

# Run the script
main "$@"